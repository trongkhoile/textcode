#property strict
#include <Trade/Trade.mqh>
CTrade trade;
CPositionInfo m_position;
double myTP, mySL;
input string FileName = "signals.txt";   // file ch·ª©a t√≠n hi·ªáu t·ª´ TradingView
input double Lots = 0.1;                 // Lot t√πy ch·ªânh
input double TP_Pips = 1.5;              // TP c√°ch gi√° 1.5 gi√°
input double SL_Pips = 3;              // SL c√°ch gi√° 3 gi√°
int check = 0;
double LastBalance = 0;
//=== H√†m x√≥a kho·∫£ng tr·∫Øng ƒë·∫ßu/cu·ªëi ===
string Trim(string s)
{
   StringTrimLeft(s);
   StringTrimRight(s);
   return s;
}
int OnInit()
{
    // L·∫•y s·ªë d∆∞ hi·ªán t·∫°i khi EA b·∫Øt ƒë·∫ßu ch·∫°y
    LastBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    return(INIT_SUCCEEDED);
}

// H√†m ki·ªÉm tra thay ƒë·ªïi s·ªë d∆∞
bool CheckBalanceChange()
{
    double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    if(currentBalance > LastBalance){
        Print("üí∞ S·ªë d∆∞ tƒÉng: ", currentBalance - LastBalance);
        LastBalance = currentBalance;
        return true;
    }
    else if(currentBalance < LastBalance){
        Print("üí∏ S·ªë d∆∞ gi·∫£m: ", LastBalance - currentBalance);
        LastBalance = currentBalance;
        return false;
    }
    else{
        LastBalance = currentBalance;
        Print("S·ªë d∆∞ kh√¥ng thay ƒë·ªïi");
        return true;
    }
  // c·∫≠p nh·∫≠t cho l·∫ßn sau
}
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
    // Ki·ªÉm tra n·∫øu deal m·ªõi ƒë∆∞·ª£c th√™m (l·ªánh v·ª´a kh·ªõp ho·∫∑c ƒë√≥ng)
    Print(check);
    if (PositionsTotal() != 0){
      LastBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    }
    if(trans.type == TRADE_TRANSACTION_DEAL_ADD && PositionsTotal() == 0)
    {
        if (CheckBalanceChange() == false){
            check += 1;
        }
        else if (CheckBalanceChange() == true || check >= 5){
            check = 0;
        }
    }
}
bool IsNoPositionForSymbol(string symbol)
{
    for(int i=0; i<PositionsTotal(); i++)
    {
        if (PositionGetSymbol(i) == symbol)
            return false; // c√≥ l·ªánh cho symbol n√†y
    }
    return true; // kh√¥ng c√≥ l·ªánh n√†o cho symbol n√†y
}

bool CheckLastClosed()
{
   int total = HistoryDealsTotal();
   if(total == 0) 
   {
       Print("Kh√¥ng c√≥ l·ªánh l·ªãch s·ª≠ n√†o");
       return false; // ph·∫£i tr·∫£ v·ªÅ bool
   }

   ulong last_deal = HistoryDealGetTicket(total - 1);
   if(HistoryDealSelect(last_deal))
   {
      long reason = HistoryDealGetInteger(last_deal, DEAL_REASON);
      string sym  = HistoryDealGetString(last_deal, DEAL_SYMBOL);
      double price = HistoryDealGetDouble(last_deal, DEAL_PRICE);

      if(reason == DEAL_REASON_TP)
      {
         Print("‚úÖ L·ªánh ", sym, " v·ª´a TP t·∫°i ", price);
         return true;  // tr·∫£ v·ªÅ true n·∫øu TP
      }
      else if(reason == DEAL_REASON_SL)
      {
         Print("‚ùå L·ªánh ", sym, " v·ª´a SL t·∫°i ", price);
         return false; // tr·∫£ v·ªÅ false n·∫øu SL
      }
      else
      {
         Print("‚ÑπÔ∏è L·ªánh ", sym, " ƒë√≥ng v√¨ l√Ω do kh√°c: ", reason);
         return false; // ho·∫∑c true t√πy √Ω b·∫°n
      }
   }

   return false; // tr∆∞·ªùng h·ª£p kh√¥ng select ƒë∆∞·ª£c deal
}

//=== H√†m x√≥a t·∫•t c·∫£ l·ªánh ch·ªù c·ªßa symbol ===
bool DeletePendingOrders(string symbol)
{
   bool deleted = false;
   int total = OrdersTotal();

   for(int i = total - 1; i >= 0; i--)
   {
      ulong ticket = OrderGetTicket(i);
      if(OrderSelect(ticket))
      {
         string sym = OrderGetString(ORDER_SYMBOL);
         long type  = OrderGetInteger(ORDER_TYPE);

         // X√≥a n·∫øu l√† l·ªánh ch·ªù
         if(sym == symbol &&
            (type == ORDER_TYPE_BUY_LIMIT  ||
             type == ORDER_TYPE_SELL_LIMIT ||
             type == ORDER_TYPE_BUY_STOP   ||
             type == ORDER_TYPE_SELL_STOP))
         {
            if(trade.OrderDelete(ticket))
            {
               Print("üßπ ƒê√£ x√≥a l·ªánh ch·ªù c≈©: ", ticket, " (", sym, ")");
               deleted = true;
            }
            else
            {
               Print("‚ö†Ô∏è L·ªói khi x√≥a l·ªánh ch·ªù ", ticket, ": ", _LastError);
            }
         }
      }
   }
   return deleted;
}
bool DeletePendingBuyStop(string symbol)
{
    bool deleted = false;
    int total = OrdersTotal();

    for(int i = total - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string sym = OrderGetString(ORDER_SYMBOL);
            long type  = OrderGetInteger(ORDER_TYPE);

            // X√≥a ch·ªâ n·∫øu l√† l·ªánh Buy Stop
            if(sym == symbol && type == ORDER_TYPE_BUY_STOP)
            {
                if(trade.OrderDelete(ticket))
                {
                    Print("üßπ ƒê√£ x√≥a l·ªánh Buy Stop c≈©: ", ticket, " (", sym, ")");
                    deleted = true;
                }
                else
                {
                    Print("‚ö†Ô∏è L·ªói khi x√≥a l·ªánh Buy Stop ", ticket, ": ", _LastError);
                }
            }
        }
    }
    return deleted;
}
bool DeletePendingSellStop(string symbol)
{
    bool deleted = false;
    int total = OrdersTotal();

    for(int i = total - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string sym = OrderGetString(ORDER_SYMBOL);
            long type  = OrderGetInteger(ORDER_TYPE);

            // X√≥a ch·ªâ n·∫øu l√† l·ªánh Sell Stop
            if(sym == symbol && type == ORDER_TYPE_SELL_STOP)
            {
                if(trade.OrderDelete(ticket))
                {
                    Print("üßπ ƒê√£ x√≥a l·ªánh Sell Stop c≈©: ", ticket, " (", sym, ")");
                    deleted = true;
                }
                else
                {
                    Print("‚ö†Ô∏è L·ªói khi x√≥a l·ªánh Sell Stop ", ticket, ": ", _LastError);
                }
            }
        }
    }
    return deleted;
}

string GetJsonValue(string json, string key)
{
   int p = StringFind(json, "\"" + key + "\"");
   if(p == -1) return "";
   int colon = StringFind(json, ":", p);
   if(colon == -1) return "";
   int comma = StringFind(json, ",", colon);
   if(comma == -1) comma = StringFind(json, "}", colon);
   if(comma == -1) return "";
   string val = StringSubstr(json, colon+1, comma - colon - 1);
   StringReplace(val, "\"", "");
   val = Trim(val);
   return val;
}
void CloseAllOrders()
{
   int total = PositionsTotal();
   for(int i = total-1; i >= 0; i--)
   {
      if(m_position.SelectByIndex(i))
      {
         string sym   = m_position.Symbol();
         ulong  ticket= m_position.Ticket();
         double volume= m_position.Volume();

         if(sym == _Symbol)
         {
            Print("üîª ƒê√≥ng l·ªánh ticket=", ticket, " vol=", volume);

            // MT5 Hedging ‚Üí ƒë√≥ng t·ª´ng l·ªánh
            if(!trade.PositionClosePartial(ticket, volume))
            {
               Print("‚ùå L·ªói ƒë√≥ng ticket=", ticket,
                     " code=", GetLastError());
            }
         }
      }
   }
}

//=== X·ª≠ l√Ω t√≠n hi·ªáu JSON ===
void ProcessSignal(string json)
{
   Print("üì© Nh·∫≠n t√≠n hi·ªáu: ", json);
   
   string action = GetJsonValue(json, "ACTION");
   string symbol = GetJsonValue(json, "SYMBOL");
   double price  = StringToDouble(GetJsonValue(json, "PRICE"));

   if(symbol != "" && symbol != _Symbol)
   {
      Print("‚ö†Ô∏è B·ªè qua t√≠n hi·ªáu v√¨ SYMBOL=", symbol, " kh√°c chart ", _Symbol);
      return;
   }

   // C·∫≠p nh·∫≠t Martingale TP d·ª±a tr√™n l·ªánh v·ª´a ƒë√≥ng

   double lot = Lots;           // Lot c·ªë ƒë·ªãnh
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if (check == 0){
      myTP = TP_Pips;
      mySL = SL_Pips;    
      Print(myTP);    
   } // SL c·ªë ƒë·ªãnh
   else{
      myTP = myTP*2;
      mySL = mySL; 
      Print(myTP);       
   }
   if(action == "BUY")
   {
      CloseAllOrders();
      trade.Buy(lot, _Symbol, 0, ask - mySL, ask + myTP, "TV Buy");
   }
   else if(action == "SELL")
   {
      CloseAllOrders();
      trade.Sell(lot, _Symbol, 0, bid + mySL, bid - myTP, "TV Sell");
   }
   else if(action == "BUY_STOP" && IsNoPositionForSymbol(symbol))
   {
      DeletePendingBuyStop(symbol);
      trade.BuyStop(lot, price, _Symbol, price - mySL, price + myTP, ORDER_TIME_GTC, 0, "TV BuyStop");
   }
   else if(action == "SELL_STOP" && IsNoPositionForSymbol(symbol))
   {
      DeletePendingSellStop(symbol);
      trade.SellStop(lot, price, _Symbol, price + mySL, price - myTP, ORDER_TIME_GTC, 0, "TV SellStop");
   }
   else
   {
      Print("‚ö†Ô∏è Kh√¥ng hi·ªÉu ACTION: ", action);
   }
}

//=== OnTick ƒë·ªçc file t√≠n hi·ªáu ===

void OnTick()
{
   int handle = FileOpen(FileName, FILE_READ|FILE_TXT|FILE_SHARE_READ|FILE_ANSI);
   if(handle != INVALID_HANDLE)
   {
      string line;
      while(!FileIsEnding(handle))
      {
         line = FileReadString(handle);
         if(line != "")
         {
            ProcessSignal(line);
         }
      }
      FileClose(handle);
      
      // X√≥a n·ªôi dung file sau khi x·ª≠ l√Ω ƒë·ªÉ tr√°nh nh·ªìi l·ªánh
      int clear = FileOpen(FileName, FILE_WRITE|FILE_TXT);
      if(clear != INVALID_HANDLE)
      {
         FileWrite(clear, "");
         FileClose(clear);
      }
   }
}